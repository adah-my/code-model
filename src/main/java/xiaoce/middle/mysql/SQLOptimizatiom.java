package xiaoce.middle.mysql;

public class SQLOptimizatiom
{
    /**
     * 索引与优化原理：
     *
     * 一. 为什么要学SQL优化
     * 绝大多数情况下，内存中数据的处理耗时几乎可以忽略不计。
     * 插入行所需的时间有以下因素决定
     *      连接：30%   向服务器发送查询：20%  解析查询：20%  插入行：10*行的大小  插入索引：10*索引数  结束：10%
     *      可发现大部分时间耗费在客户端与服务端通信的时间，因此可以使用insert包含多个值来减少客户端和服务端之间的通信。
     *
     * 到这里大家应该能形成一个认知：一次正常的请求，最可能出现性能瓶颈的地方就是网络请求以及IO操作（通常而言性能瓶颈往往出现在数据库）
     * 想要优化数据的查询，大方向有两个：
     *      1.优化关系型数据库本身，比如增加索引等
     *      2.借助大数据和ES，转嫁查询压力
     *
     * 在我看来，对于一般的Java开发而言，SQL优化分为几个层次：
     *      1. 索引优化 70%
     *      2. 事务及锁 20%
     *      3. 读写分离 10%
     * 其中，索引优化是最重要的、也是一般Java开发人员最常用的手段。
     *
     * 二. 索引的类型：
     *      1. 全文索引 ：（ MySQL这种关系型数据库并不适合进行全文索引（考虑Elastic Search），索引全文索引一般很少使用 ）
     *      2. 普通索引
     *      3. 空间索引
     *      4. 唯一索引 ：（ 普通索引 + 不同重复 ）
     *      主键索引：（唯一索引 + 非NULL）
     *
     * 三. 索引的实现方式：（这和索引类型不冲突，比如对于普通索引，我们可以使用B+树的结构组织索引，也可以指使用hash算法实现。）
     *      1.BTREE(B+树)
     *      2.HASH(哈希)  特征：即使原数据具备一定的相关性，经过hash映射后得到的结果也会变得“很散”，没有规律可循。
     *
     * 所谓hash索引，其实就是利用hash算法为索引列计算得到唯一的存储地址，一般来说这个地址是不会重复的（重复的情况被称为hash冲突）
     * hash索引的优劣势：
     *      优势：速度非常快，只需要一次计算即可得到地址，时间复杂度O(1),而B+树是O(logn)
     *      劣势：不支持模糊查询、范围查询、索引排序（本身就是不规则的，如何利用索引排序呢）
     *
     * 四. 索引的创建：
     *      1.起初，建表时顺便建立索引
     *      2.后期，修改表结构创建索引（一般都会这样，因为很难未卜先知，提前优化等于瞎优化）
     *
     * -- 1.添加PRIMARY KEY （主键索引）
     * ALTER TABLE 'table_name' ADD PRIMARY KEY ('column');
     * -- 2.添加UNIQUE（唯一索引）
     * ALTER TABLE 'table_name' ADD UNIQUE ('column');
     * -- 3.添加普通索引
     * ALTER TABLE 'table_name' ADD INDEX index_name ('column');
     * -- 4.添加FULLTEXT（全文索引）
     * ALTER TABLE 'table_name' ADD FULLTEXT ('column');
     * -- 5.添加联合索引
     * ALTER TABLE 'table_name' ADD INDEX inex_name ('column1', 'column2', 'column3');
     *
     * 五. 索引的好与坏
     * 索引的优势是：
     *      加快查询速度（包括关联查询）
     *      加快排序速度（ORDER BY）
     *      加快分组速度（GROUP BY）
     *
     * 索引的劣势：
     *      创建索引是需要付出代价的，主要体现在维护成本、空间成本和回表成本。也就是说索引能提高查询效率，但往往会降低增删改的速度（字段新增几百个字，需要额外编排目录把，要多占几页纸吧）
     *      如果使用了联合索引，还需要考虑吧索引失效问题
     *      太多的索引会增加查询优化器的选择时间（选择太多也麻烦）
     *
     * 六. 建立索引的原则
     * 创建索引有4个大原则：
     *      索引并不是越多越好，联合索引应该优于多个单列索引
     *      索引应该建立在区分度较高的字段
     *      尽量给重复查询频繁的字段创建索引，避免你为修改频繁的字段创建索引
     *      避免重复索引
     *
     * 七. MySQL常用引擎 （MyISAM、InnoDB）
     * MyISAM的每张表在存储时会分为3个文件： 表结构  表数据  索引 （也就是说，表数据和索引是分别独立存储的）
     * InnoDB的表数据在存储只分为2个文件：表结构  表数据+索引 （需要主义的是，InnoDB所有表的数据和索引都在同一个文件里）
     *
     * 八. 聚簇索引与非聚簇索引
     * 对于BTREE索引而言，从数据组组织形式来看，索引又可以分为两大类：
     *      1.聚簇索引
     *      2.非聚簇索引
     *
     * 所谓聚簇索引，可以简单理解为索引和数据是”聚合“在一起的，而非聚簇索引的数据和索引是分开的。
     * 所以根据InnoDB引擎的主键索引查询时无需回表，每一行完整的数据都直接挂在叶子节点下，可以直接返回。也即是说，对于InnoDB的主键索引而言，数据即索引，索引即数据。
     * InnoDB的索引也并不是都不需要回表，根据是否需要回表其实可以分为两类：主键索引、辅助索引（或者叫二级索引、普通索引）
     * 为什么要做这种区分？ 假设一个场景：
     * 新建
     * 会什么要做这种区分呢？
     * 假设一个场景：
     * 新建一张表后，自然会产生主键索引。但后期发现name字段查询很频繁，于是加了name索引。
     * 相同的是最底层叶子节点都挂着完整的表数据。也就是说，磁盘中存了两份一摸一样的student数据。且不说数据冗余，更新时还可能会产生数据不一致（要同步数据，确保多张表的数据一致性）。
     * 所以InnoDB的做法是，辅助索引只存储索引列+主键，必要时进行”回表“操作。
     *
     * MyISAM：非聚簇索引
     * InnoDB：
     *      聚簇索引：主键索引，叶子节点是表数据，不需要回表
     *      非聚簇索引：辅助索引（唯一索引、普通索引），叶子节点是主键，必要时需要根据主键回表查询
     *
     * InnoDB每张表只能有一个主键索引，辅助索引则可以有多个。表数据只有一份，挂在主键索引下面。
     * 需要注意的是，如有可能，应该尽量避免回表。SQL优化的本质其实就是减少/减小磁盘IO，而回表必然会增加磁盘IO次数
     * 通常情况下辅助索引查询都是需要徽标的，比如主键索引查询多扫描一颗索引树（自身+主键索引），十几编写SQL时，应该尽量走主键索引。
     *
     * 九. 覆盖索引（索引的字段 >= 查询需要的字段）：
     * 当辅助索引上的字段完全满足本次查询的列时，就是所谓的索引覆盖，这是一个好消息，意味着不需要回表，查询效率将会大大提升。
     * 这也是为什么SQL优化原则中经常会强调：尽量只取必要的字段，避免SELECT * （提高索引覆盖的几率，查询的字段越多，几率越低）
     * 即使目前表中只有两个字段且已经索引覆盖，也不要写SELECT *。因为后期随着业务扩展，这张表会新增其他字段，此时SELECT *将会不再覆盖索引！
     *
     * 所以，能否覆盖索引不取决于索引单方面，需要查询配合。
     *
     * 
     */


























}
