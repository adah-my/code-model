package xiaoce.middle.mysql;

public class MySQLStructure
{
    /**
     * MySQL存储结构的演变：
     *
     * 1.线性结构（列表）：
     *      一个线程表如果存入了42亿条数据，想要找到id=100的数据，游标只需要爬99格即可，但如果id=10000000，就要爬将近1000w个格子才能返回。
     *      对于这42亿数据，平均查询次数是21亿次。无法使用二分，因为42亿数据不可能都在内存中。
     *
     * 2.二叉查找数：
     *      如果用一棵树来存储42亿条数据，即2^32=42亿，树的层级是32，最差的情况也只要查32次（需要是二叉平衡树），远远小于线性结构的平均21亿次，这是非常夸张的。
     *      如果按1,2,3,4...的顺序插入数据时，它其实变成了线性结构，这显然不是我们想要的
     *
     * 3.二叉平衡树
     *      二叉平衡树会在数据插入完毕后自动调整节点，好让”树的层级“不会太深
     *      按理来说，42亿数据中找一条记录只需要比较32次，尤其对于CPU来说，别说32次比较，哪怕32w次简单数据的比较都不会超过0.1秒。（这很理想不是吗！但是！）
     *      数据存在磁盘中，没问题。数据按树结构组织，没问题。查询时分块读取数据，有很大问题。
     *      磁盘IO是非常耗时的操作，真正的瓶颈是IO（网络IO和磁盘IO）。就好比F1赛车、奥迪A4和拖拉机一起跑在北京四环路上，限制他们的不是引擎，而是堵车。
     *      (32次磁盘IO是无法接受的)
     *
     * 4.B树
     *      想要优化当前数据库，关键是减少磁盘IO次数，而影响IO次数的关键因素就是树的层级(深度)！
     *      大家想想 2^32 = 42亿，想要减少32，只要增大那个2，不就可以了吗！！
     *      所以到这里，我们已经有了答案了：想要减少二叉平衡树的磁盘IO次数，需要增加他的“叉”，变成“N叉平衡树”，从而减少树的深度。
     *
     *      实际上MySQL索引采用的数据结构是B+树，而不是B树！！为什么不用B树呢？
     *      在操作系统中有个叫“页”的概念，是用来存储数据的一种单位，大小为4k。MySQL中也有“页”的概念，但大小为16k，你可以理解为MySQL中的“页”就是B树上的一个节点。
     *      那么问题来个：你知道日常开发中，表中的一行数据大概占多少字节吗？对于一张普通的表，每个节点最多存十几条数据。
     *
     *      所以，把整行数据塞到节点中，有点太浪费了，我们其实可以把每一行数据的主键存进去。即使使用bigint类型做主键，一个主键也就8个字节。
     *      假设每个主键对应一个addr(指针)，MuSQL中一个指针为6个字节，那么节点内每个主键-地址这样形式的数据能存16*1024/14=1170个。
     *      这其实就是 B+树 对 B树 的改造
     *
     * 5.B+树
     *      所谓的B+树，就是把原先B树中分散在各个节点的数据都“赶到”最底层的叶子节点。
     *      1 * 1170 * 1170*16 = 2000w
     *      最终，一棵3层的B+树，最底下的叶子节点总共能存2000w条数据。
     *
     *      B+树的两个很重要的特征：
     *      1.非叶子节点不存数据
     *      2.叶子节点数据用链表相连（叶子节点是有序链表，可以帮助做范围查询）
     *
     */
}
