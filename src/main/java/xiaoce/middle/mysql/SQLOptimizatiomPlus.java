package xiaoce.middle.mysql;

public class SQLOptimizatiomPlus
{
    /**
     *
     * 联合索引
     * 联合索引其实要比单列索引难很多，很多SQL优化原则都是针对万恶的联合索引搞出来的，比如大名鼎鼎的”最左匹配原则“
     * 虽然联合索引容易引发各种问题，看起来不那么容易驯服，但他在提高索引利用率、加快分组、排序等方面却有很大的作用，所以实际开发时，联合索引一般来说应该优于单列索引。
     *
     * 相信大家都有很多疑问：
     * 1.联合索引到底长啥样？ (叶子节点数据为主键id)
     *      还是一棵树，不会因为时联合索引，就变成多棵树。
     *      索引节点回存储多列，比如原先单列索引的节点会存储[name, name, name...]，而多列索引的节点内会存储[[name, age],[name, age],[name, age]...]
     *
     * 2.查询时是怎么检索的呢？
     *
     * 现在要往数据库插入一条数据(bravo, 18, "杭州", "18255555556")，插入时需要维护索引，所以需要沿着索引找到数据所在的位置并在叶子节点的表数据中插入。
     * 插入数据的过程其实伴随着索引的维护。换句话说，这样沿着索引比较后插入的数据，本身就是有序的，符合联合索引的顺序。
     * 因为本身插入或更新时，都是按照某种规则维护的。当你ORDER BY的规则与维护索引的规则一致时（都是根据身高、成绩），此时索引就能加快排序，因为这个时候根本不用排序。
     * 所以记住，最快的排序就是不用排序，也就是利用索引排序。把对顺序的维护分散到每一次增删改的过程中，而不是查询时在匆忙从零开始排序。
     *
     * 3.为什么对于联合索引index(a,b,c)，查询条件WHERE b=1,c=2无法利用索引呢？
     *
     * 最左匹配原则：WHERE条件查询
     * 为什么对于联合索引index(name, age)，条件WHERE age=25无法利用索引 （因为不符合最左匹配原则）
     * 上面分析过，数据总要经过索引比较后才插入，所以数据天然就是索引顺序排列的。
     * 当我们拿着WHERE子句的条件(age=25)顺着索引树比较时，是得不到正确的结果的。因为当初这棵树排序的第一个条件是name，而不是age。
     *
     * 假设联合索引是index(a, b, c)，来看几个最左普配原则的案例：
     *      WHERE a, b, c  ✔
     *      WHERE a, b  ✔   (只能匹配a,b)
     *      WHERE a, c  ✔   (只能匹配a)
     *      WHERE b, c  ❌
     *
     * 最左匹配原则：ORDER BY
     * 上面说过了，对于index(name, age)的索引树，最底层的数据本身就是先按name，再按age排序的。
     * 当ORDER BY的条件刚好是ORDER BY name，age时，直接查询即可，无需排序，因为数据在插入时就按索引顺序排好了。
     * 反过来讨论：如果没有利用索引排序，或者无法利用索引排序时，会发生什么呢?  filesort!!!(利用内存或磁盘自己重新排序)
     * 那么，什么情况下会导致ORDER BY无法利用索引排序呢？
     * 以联合索引index(name, age)为例，以下情况无法利用索引排序：
     *      ORDER BY age, name (字段顺序不一致)
     *      ORDER BY name DESC, age ASC (字段排序方式不同步，DESC和ASC混着来)
     * 但以下情况仍可以利用索引排序：
     *      ORDER BY name DESC, age DESC (字段顺序和索引顺序一致即可，全部DESC或ASC都没关系)
     *
     * 最左匹配原则：GROUP BY
     * GROUP BY其实可以看作两步：先排序，后归并。
     * 一般对于GROUP BY的优化，就是尽可能让它也走索引排序。当它和联合索引顺序一致时，GROUP BY会跳过排序，直接归并，从而达到优化的目的。
     *
     *
     * 联合索引的使用场景：
     *
     * 场景一：多条件查询，提高利用率
     * 如果发现很多SQL的WHERE条件经常是多个相同的字段，比如SELECT xxx WHERE a,b,c、SELECT xxx WHERE a,b、SELECT xxx WHERE a,c等，此时可以考考虑创建联合索引index(a,b,c)
     * 这里有几条规则需要注意：
     *      WHERE条件的书写顺序并不影响是否联合索引。比如WHERE a,b,c 和 WHERE b,c,a都可以走index(a,b,c)
     *      但WHERE b,c是不行的，因为缺少a，而WHERE a,c只能利用部分索引
     *      创建索引时，最好把区分度高的排在前面（注意我说的是创建索引的顺序，而不是WHERE条件的顺序）
     * 第三条需要大家再仔细品味一下，比如要给id_card和name建立联合索引，如果你建的是index(name, id_card)，就会浪费无谓的IO再name查找上：
     * 先找到全国同名同姓的，再根据id_card匹配。而如果创建index(id_card, name)，那么id_card是唯一的，区分度极高，基本就是一击必中。
     *
     * 场景二：避免回表
     * 上一篇已经介绍过了，如果走辅助索引并回表，就会无端多一次对主键索引的扫描。比如对于只有之间索引和name索引的表执行以下SQL：
     * SELECT id, name, age FROM table name='xxxx';
     * 由于name索引只包含了id和name，而SELECT的列却是id、name、age，此时MySQL底层不得不回表，拿着id再跑一遍主键索引，把age给捞出来。
     * 可行的解决办法是：添加联合索引index(name, age)，这样辅助索引上就同时包含id、name、age，可以直接返回。
     * 当然啦，并不是只有联合索引才能使用索引覆盖，只要辅助索引上的字段满足SELECT的列即可，所以即使是单列索引index(name),也是可以避免回表的，比如：
     * SELECT id, name FROM table WHERE name='xxx';
     * 但大家要认识到，实际开发索引覆盖可遇不可求，基本还是回表的情况多一些。比如，即使你定了联合索引index(name, age)，但实际上确实要查所有列怎么办？此时还是要乖乖回表（好歹走了辅助索引了，知足吧）。
     *
     * 场景三：索引排序
     * 当你建了联合索引index(a,b,c)，那么每次增删改查都会按照这个顺序维护。如果查询是需要的顺序刚好是a,b,c，就可以直接返回数据，无需排序，美其名曰”利用索引排序“。
     * 有个比较特别的地方是，WHERE和ORDER BY可以”联手“玩转联合索引，比如对于index(a,b,c)，并不是只有WHERE a,b,c或者ORDER BY a,b,c才能利用联合索引，WHERE a=1 ORDER BY b,c也是可以的
     *
     * 讲完了这三个场景，再稍微注意以下联合索引失效的问题即可（之说两个最常用的）：
     *      最左匹配原则
     *      注意范围查询，比如WHERE a>1 and b=2 and c=3，那么就只能用到a啦
     *
     * 场景四：COUNT统计
     * 虽说一般大数量不推荐直接使用COUNT函数，但绝大部分公司都是小公司，一张表不会很大，所以初期COUNT也无妨，但最好尽量走索引。比如要求统计天猫平台下的店主粉丝数量：
     * SELECT COUNT(*) FROM t_user_follow WHERE uid=123 and platform=6 and follow_status=1;
     * 此时最好建立索引index(uid, platform, foolow_status)
     *
     *
     *
     * MySQL架构图
     *
     * 客户端 ---客户端/服务器通信协议--> --SQL-->查询缓存-->结果
     *                                              --> 解析器 --语法解析--> 解析树 ---> 预处理器 ---> 新解析树 ---->查询优化器
     * 查询优化器 ---> 执行计划 ---> 查询执行引擎 ---> API接口查询 ---> 数据 ---> 查询执行引擎 --->结果
     *                                                                               --->缓存
     */



















































































}
